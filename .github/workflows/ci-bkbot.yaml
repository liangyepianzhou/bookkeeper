# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
# 说明（中文注释）：
# 该 GitHub Actions 工作流用于在 PR/Issue 评论中使用命令 /bkbot 来重跑 CI。
# 仅支持命令：/bkbot rerun [关键字]
# - /bkbot rerun            => 重跑同一 head SHA 下各工作流的最新一次运行，且仅限结论为 failure/cancelled/timed_out/skipped 的运行（整条 run）
# - /bkbot rerun <关键字>    => 不限工作流/Job 状态，获取最新运行中的全部 Job，按名称匹配关键字后逐个重跑
# 日志说明：
# - 失败/取消/超时/跳过 的 jobs 会从“所有最新工作流运行”中扫描（包含 in_progress 的运行），从而捕获运行中途已失败或跳过的 jobs。
# 触发条件：当新评论创建且包含 /bkbot 时触发。

name: BookKeeper Bot

on:
  issue_comment:
    types: [created]

permissions:
  actions: write
  contents: read

jobs:
  bkbot:
    runs-on: ubuntu-24.04
    timeout-minutes: 10
    if: github.event_name == 'issue_comment' && contains(github.event.comment.body, '/bkbot')
    steps:
      - name: Execute bkbot command
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const commentBody = context.payload.comment.body.trim();
            const botCommandPrefix = '/bkbot';
            const botTargetRepository = context.repo;
            
            if (!commentBody.startsWith(botCommandPrefix)) {
              console.log('Not a bkbot command, skipping it ...');
              return;
            }
            
            const commands = commentBody.split(/\s+/);
            const botCommand = commands[1] || '';
            if (botCommand !== 'rerun') {
              console.log(`Invalid bot command '${botCommand}', only 'rerun' is supported. Skip ...`);
              return;
            }
            
            // 关键字支持多词：把第3个及之后的 token 合并
            const checkName = (commands.length > 2) ? commands.slice(2).join(' ').trim() : '_all';
            
            const prNum = context.payload.issue.number;
            
            let pr;
            try {
              ({ data: pr } = await github.rest.pulls.get({
                owner: botTargetRepository.owner,
                repo: botTargetRepository.repo,
                pull_number: prNum
              }));
            } catch (e) {
              console.error(`Failed to fetch PR #${prNum}: ${e.message}`);
              return;
            }
            
            const headSha = pr.head.sha;
            const prBranch = pr.head.ref;
            const prUser = (pr.head && pr.head.user && pr.head.user.login) ? pr.head.user.login : pr.user.login;
            const prHtmlUrl = pr.html_url;
            
            console.log(`Handling bkbot command for PR #${prNum} ${prHtmlUrl} | keyword: ${checkName}`);
            
            // 获取同一作者+分支的 runs，后续再按 headSha 过滤
            let page = 1;
            let allRunsRaw = [];
            while (true) {
              const { data: runs } = await github.rest.actions.listWorkflowRunsForRepo({
                owner: botTargetRepository.owner,
                repo: botTargetRepository.repo,
                actor: prUser,
                branch: prBranch,
                per_page: 100,
                page
              });
              const wr = runs.workflow_runs || [];
              if (wr.length === 0) break;
              allRunsRaw.push(...wr);
              page++;
            }
            
            const allRuns = allRunsRaw.filter(run => run.head_sha === headSha);
            if (allRuns.length === 0) {
              console.error(`No workflow runs found for head SHA ${headSha} on branch ${prBranch}. Nothing to rerun.`);
              return;
            }
            
            // 每个 workflow 只保留最新一次
            allRuns.sort((a, b) => {
              if (a.workflow_id !== b.workflow_id) return a.workflow_id - b.workflow_id;
              return new Date(b.created_at) - new Date(a.created_at);
            });
            const latestRuns = [];
            const seenWorkflows = new Set();
            for (const run of allRuns) {
              if (!seenWorkflows.has(run.workflow_id)) {
                seenWorkflows.add(run.workflow_id);
                latestRuns.push(run);
              }
            }
            
            async function listAllJobsForRun(runId) {
              let jobs = [];
              let jobPage = 1;
              while (true) {
                const { data: jobsPage } = await github.rest.actions.listJobsForWorkflowRun({
                  owner: botTargetRepository.owner,
                  repo: botTargetRepository.repo,
                  run_id: runId,
                  per_page: 100,
                  page: jobPage
                });
                const jobList = jobsPage.jobs || [];
                if (jobList.length === 0) break;
                jobs.push(...jobList);
                if (jobList.length < 100) break;
                jobPage++;
              }
              return jobs;
            }
            
            async function rerunSingleJob(jobId, jobName, runName, runUrl) {
              try {
                if (github.rest.actions.reRunJobForWorkflowRun) {
                  await github.rest.actions.reRunJobForWorkflowRun({
                    owner: botTargetRepository.owner,
                    repo: botTargetRepository.repo,
                    job_id: jobId
                  });
                } else {
                  await github.request('POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun', {
                    owner: botTargetRepository.owner,
                    repo: botTargetRepository.repo,
                    job_id: jobId
                  });
                }
                console.log(`Re-ran job '${jobName}' (job_id: ${jobId}) in run '${runName}'. Follow progress at ${runUrl}`);
                return true;
              } catch (error) {
                console.log(`Failed to rerun job '${jobName}' (job_id: ${jobId}) in run '${runName}': ${error.message}`);
                return false;
              }
            }
            
            const TARGET_CONCLUSIONS = new Set(['failure', 'cancelled', 'timed_out', 'skipped']);
            
            // 日志 1：失败/取消/超时/跳过 的工作流运行（仅最新一次）
            const interestingRuns = latestRuns.filter(run => TARGET_CONCLUSIONS.has(run.conclusion));
            console.log('--- Failed/Cancelled/Timed-out/Skipped workflow runs (latest per workflow for this head SHA) ---');
            if (interestingRuns.length === 0) {
              console.log('None');
            } else {
              for (const run of interestingRuns) {
                console.log(`- ${run.name || '(unnamed run)'} | ${run.html_url} | conclusion=${run.conclusion} | run_id=${run.id}`);
              }
            }
            
            // 日志 2：失败/取消/超时/跳过 的 jobs（从所有 latestRuns 扫描，含进行中的运行）
            const failedJobsLog = [];
            for (const run of latestRuns) {
              try {
                const jobs = await listAllJobsForRun(run.id);
                for (const job of jobs) {
                  if (TARGET_CONCLUSIONS.has(job.conclusion)) {
                    failedJobsLog.push({
                      job_id: job.id,
                      job_name: job.name,
                      job_url: job.html_url,
                      run_name: run.name,
                      run_url: run.html_url,
                      job_conclusion: job.conclusion
                    });
                  }
                }
              } catch (error) {
                console.log(`Failed to list jobs for run '${run.name}': ${error.message}`);
              }
            }
            console.log('--- Failed/Cancelled/Timed-out/Skipped jobs (scanned from all latest runs, including in-progress) ---');
            if (failedJobsLog.length === 0) {
              console.log('None');
            } else {
              for (const j of failedJobsLog) {
                console.log(`- ${j.job_name} | conclusion=${j.job_conclusion} | in run='${j.run_name || '(unnamed run)'}' | ${j.job_url || j.run_url} | job_id=${j.job_id}`);
              }
            }
            
            let rerunWorkflowAllCount = 0;
            let rerunMatchedJobsCount = 0;
            
            if (checkName === '_all') {
              // 未指定关键字：仅重跑 failure/cancelled/timed_out/skipped 的运行（整条 run）
              const runsToRerun = latestRuns.filter(run => TARGET_CONCLUSIONS.has(run.conclusion));
            
              if (runsToRerun.length === 0) {
                console.log('No failure/cancelled/timed_out/skipped workflow runs found to rerun. Nothing to do.');
              } else {
                for (const run of runsToRerun) {
                  try {
                    if (github.rest.actions.reRunWorkflow) {
                      await github.rest.actions.reRunWorkflow({
                        owner: botTargetRepository.owner,
                        repo: botTargetRepository.repo,
                        run_id: run.id
                      });
                    } else {
                      await github.request('POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun', {
                        owner: botTargetRepository.owner,
                        repo: botTargetRepository.repo,
                        run_id: run.id
                      });
                    }
                    rerunWorkflowAllCount++;
                    console.log(`Re-ran entire workflow run '${run.name}' (run_id=${run.id}, conclusion=${run.conclusion}). Follow progress at ${run.html_url}`);
                  } catch (error) {
                    console.log(`Failed to re-run entire workflow run '${run.name}' (run_id=${run.id}): ${error.message}`);
                  }
                }
              }
            } else {
              // 指定关键字：不论状态先获取并匹配，run 未完成则跳过并给出明确提示
              console.log(`Job keyword specified: '${checkName}'. Will scan all latest workflow runs and try to re-run matching jobs.`);
            
              let matchedJobsFound = 0;
              let matchedJobsInNonCompletedRuns = 0;
            
              for (const run of latestRuns) {
                let jobs;
                try {
                  jobs = await listAllJobsForRun(run.id);
                } catch (error) {
                  console.log(`Failed to list jobs for run '${run.name}' (${run.html_url}): ${error.message}`);
                  continue;
                }
                if (!jobs || jobs.length === 0) {
                  console.log(`No jobs found for run '${run.name}' (${run.html_url}).`);
                  continue;
                }
            
                for (const job of jobs) {
                  const isNameMatched = job.name && job.name.includes(checkName);
                  if (!isNameMatched) continue;
            
                  matchedJobsFound++;
            
                  // GitHub API 限制：只有当 workflow run.status === 'completed' 时才能重跑 job
                  if (run.status !== 'completed') {
                    matchedJobsInNonCompletedRuns++;
                    console.log(`Skip re-run for job '${job.name}' (job_id=${job.id}) in run '${run.name}' because the workflow run status is '${run.status}'. Try again after it completes. URL: ${job.html_url || run.html_url}`);
                    continue;
                  }
            
                  const ok = await rerunSingleJob(job.id, job.name, run.name, job.html_url || run.html_url);
                  if (ok) rerunMatchedJobsCount++;
                }
              }
            
              if (matchedJobsFound === 0) {
                console.error(`No jobs matched keyword '${checkName}' in latest runs for head SHA ${headSha}.`);
              } else if (rerunMatchedJobsCount === 0) {
                console.error(`Matched ${matchedJobsFound} job(s) for keyword '${checkName}', but none were re-ran. ${matchedJobsInNonCompletedRuns > 0 ? matchedJobsInNonCompletedRuns + ' job(s) belong to runs that are not completed yet.' : ''} Try again after the workflow run finishes.`);
              }
            }
            
            // 总结
            if (checkName === '_all') {
              if (rerunWorkflowAllCount === 0) {
                console.error(`No workflow runs were re-ran for PR #${prNum} (failure/cancelled/timed_out/skipped).`);
              } else {
                console.log(`Finished. Re-ran ${rerunWorkflowAllCount} entire workflow run(s) (failure/cancelled/timed_out/skipped).`);
              }
            } else {
              console.log(`Finished. Re-ran ${rerunMatchedJobsCount} job(s) that matched keyword '${checkName}'.`)