# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
# Description (English comments):
# This GitHub Actions workflow is used to rerun failed or cancelled CI jobs using the /bkbot command in PR/Issue comments.
# Supports only command: /bkbot rerun [keyword]
# - /bkbot rerun            => Rerun all failed/cancelled jobs in failed/cancelled workflows (only for the most recent run)
# - /bkbot rerun <keyword>  => Match by "workflow run name" (run.name) first; if not matched, then by "job.name" and only rerun the matching failed/cancelled job
# Trigger Condition: When a new comment is created and contains /bkbot.

name: BookKeeper Bot

on:
  issue_comment:
    types: [created]

permissions:
  actions: write
  contents: read

jobs:
  bkbot:
    runs-on: ubuntu-24.04
    timeout-minutes: 10
    # Only runs when event is issue_comment and the comment contains '/bkbot'
    if: github.event_name == 'issue_comment' && contains(github.event.comment.body, '/bkbot')
    steps:
      - name: Execute bkbot command
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Read comment text and trim whitespace
            const commentBody = context.payload.comment.body.trim();
            // Bot command prefix
            const botCommandPrefix = '/bkbot';
            // Target repository info (owner/repo)
            const botTargetRepository = context.repo;
            
            // Skip if comment does not start with '/bkbot'
            if (!commentBody.startsWith(botCommandPrefix)) {
              console.log('Not a bkbot command, skipping it ...');
              return;
            }
            
            // Split comment by whitespace to extract command and parameters
            // Only supports the following two formats:
            //   /bkbot rerun
            //   /bkbot rerun <checkNameKeyword>
            const commands = commentBody.split(/\s+/);
            const botCommand = commands[1] || '';
            
            // Only supports 'rerun' command
            if (botCommand !== 'rerun') {
              console.log(`Invalid bot command '${botCommand}', only 'rerun' is supported. Skip ...`);
              return;
            }
            
            // If the keyword is not provided, default to '_all' (rerun all failed or cancelled jobs)
            const checkName = (commands[2] && commands[2].trim()) ? commands[2].trim() : '_all';
            
            // Issue/PR number where the current comment is posted (issue_comment event also includes PR)
            const prNum = context.payload.issue.number;
            
            // Get PR details (to obtain headSha, branch, author, etc.)
            let pr;
            try {
              ({ data: pr } = await github.rest.pulls.get({
                owner: botTargetRepository.owner,
                repo: botTargetRepository.repo,
                pull_number: prNum
              }));
            } catch (e) {
              console.error(`Failed to fetch PR #${prNum}: ${e.message}`);
              return;
            }
            
            // Extract key information from the PR
            const headSha = pr.head.sha;              // Latest commit SHA of the PR
            const prBranch = pr.head.ref;             // PR source branch name
            // In some cases pr.head.user might be empty, fallback to pr.user
            const prUser = (pr.head && pr.head.user && pr.head.user.login) ? pr.head.user.login : pr.user.login;
            const prHtmlUrl = pr.html_url;            // PR link
            
            console.log(`Handling bkbot command for PR #${prNum} ${prHtmlUrl} | keyword: ${checkName}`);
            
            // Fetch workflow run list triggered by this user and this branch in the repository
            // Then only keep runs matching the current headSha
            let page = 1;
            let allRunsRaw = [];
            
            while (true) {
              const { data: runs } = await github.rest.actions.listWorkflowRunsForRepo({
                owner: botTargetRepository.owner,
                repo: botTargetRepository.repo,
                actor: prUser,      // Only runs triggered by the PR author (reduce interference)
                branch: prBranch,   // Only this branch
                per_page: 100,
                page: page
              });
            
              const wr = runs.workflow_runs || [];
              if (wr.length === 0) {
                break;
              }
              allRunsRaw.push(...wr);
              page++;
            }
            
            // Only keep runs matching the current headSha (ensure it's the same round of CI)
            const allRuns = allRunsRaw.filter(run => run.head_sha === headSha);
            
            if (allRuns.length === 0) {
              console.error(`No workflow runs found for head SHA ${headSha} on branch ${prBranch}. Nothing to rerun.`);
              return;
            }
            
            // To ensure only the latest run for each workflow is operated:
            // First group by workflow_id, then sort by creation time descending, keep only the latest run for each workflow
            allRuns.sort((a, b) => {
              if (a.workflow_id !== b.workflow_id) {
                return a.workflow_id - b.workflow_id;
              }
              return new Date(b.created_at) - new Date(a.created_at);
            });
            
            // Filter: Keep only the first (latest) for each workflow_id
            const latestRuns = [];
            const seenWorkflows = new Set();
            
            for (const run of allRuns) {
              if (!seenWorkflows.has(run.workflow_id)) {
                seenWorkflows.add(run.workflow_id);
                latestRuns.push(run);
              }
            }
            
            // From the latest runs, select those concluded as failure or cancelled
            const targetRuns = latestRuns.filter(run =>
              run.conclusion === 'failure' || run.conclusion === 'cancelled'
            );
            
            let rerunWorkflowFailedJobsCount = 0; // Run-level 'rerun failed jobs' count
            let rerunCancelledJobsInRunCount = 0; // Count of rerunning cancelled jobs at run-level
            let rerunJobLevelCount = 0;           // Fallback count for individual job reruns
            
            // Utility function: List all jobs for the specified run (with pagination)
            async function listAllJobsForRun(runId) {
              let jobs = [];
              let jobPage = 1;
              while (true) {
                const { data: jobsPage } = await github.rest.actions.listJobsForWorkflowRun({
                  owner: botTargetRepository.owner,
                  repo: botTargetRepository.repo,
                  run_id: runId,
                  per_page: 100,
                  page: jobPage
                });
                const jobList = jobsPage.jobs || [];
                if (jobList.length === 0) break;
                jobs.push(...jobList);
                if (jobList.length < 100) break;
                jobPage++;
              }
              return jobs;
            }
            
            // Utility function: Rerun a single job (compatible with legacy route)
            async function rerunSingleJob(jobId, jobName, runName, runUrl) {
              try {
                if (github.rest.actions.reRunJobForWorkflowRun) {
                  await github.rest.actions.reRunJobForWorkflowRun({
                    owner: botTargetRepository.owner,
                    repo: botTargetRepository.repo,
                    job_id: jobId
                  });
                } else {
                  await github.request('POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun', {
                    owner: botTargetRepository.owner,
                    repo: botTargetRepository.repo,
                    job_id: jobId
                  });
                }
                console.log(`Re-ran job '${jobName}' (job_id: ${jobId}) in run '${runName}'. Follow progress at ${runUrl}`);
                return true;
              } catch (error) {
                console.log(`Failed to rerun job '${jobName}' (job_id: ${jobId}): ${error.message}`);
                return false;
              }
            }
            
            // Prefer workflow run-level: match by run name and rerun failed/cancelled jobs
            for (const run of targetRuns) {
              const runMatches = (checkName === '_all') || (run.name && run.name.includes(checkName));
            
              if (!runMatches) {
                console.log(`Workflow name does not match '${checkName}', skip at workflow level: '${run.name}' (${run.html_url})`);
                continue;
              }
            
              // 1) First, rerun all failed jobs in this workflow run (does not affect successful jobs)
              try {
                await github.rest.actions.reRunWorkflowFailedJobs({
                  owner: botTargetRepository.owner,
                  repo: botTargetRepository.repo,
                  run_id: run.id
                });
                rerunWorkflowFailedJobsCount++;
                console.log(`Triggered 'rerun-failed-jobs' for workflow run '${run.name}'. Follow progress at ${run.html_url}`);
              } catch (error) {
                console.log(`Failed to rerun workflow failed jobs for run '${run.name}': ${error.message}`);
              }
            
              // 2) Then rerun individually all "cancelled" jobs in this run (to meet the requirement for rerunning both failed and cancelled jobs)
              try {
                const jobs = await listAllJobsForRun(run.id);
                for (const job of jobs) {
                  const conclusion = job.conclusion;
                  const isCancelled = (conclusion === 'cancelled');
                  if (isCancelled) {
                    const ok = await rerunSingleJob(job.id, job.name, run.name, run.html_url);
                    if (ok) rerunCancelledJobsInRunCount++;
                  }
                }
              } catch (error) {
                console.log(`Failed to list or rerun cancelled jobs in run '${run.name}': ${error.message}`);
              }
            }
            
            // Fallback: If a keyword is provided, and no workflow name matched, then match by job.name and rerun single failed/cancelled job(s)
            if (checkName !== '_all' && rerunWorkflowFailedJobsCount === 0 && rerunCancelledJobsInRunCount === 0) {
              console.log(`No workflow name matched '${checkName}', fallback to job-level matching ...`);
              for (const run of targetRuns) {
                try {
                  const jobs = await listAllJobsForRun(run.id);
                  for (const job of jobs) {
                    const conclusion = job.conclusion;
                    const isFailedOrCancelled = (conclusion === 'failure' || conclusion === 'cancelled');
                    const isNameMatched = job.name && job.name.includes(checkName);
                    if (isFailedOrCancelled && isNameMatched) {
                      const ok = await rerunSingleJob(job.id, job.name, run.name, run.html_url);
                      if (ok) rerunJobLevelCount++;
                    }
                  }
                } catch (error) {
                  console.log(`Failed to list or rerun jobs for run '${run.name}': ${error.message}`);
                }
              }
            }
            
            // Final summary output
            if (rerunWorkflowFailedJobsCount === 0 && rerunCancelledJobsInRunCount === 0 && rerunJobLevelCount === 0) {
              console.error(`Cannot find any failed or cancelled workflow runs or jobs in PR #${prNum} for keyword '${checkName}'. Re-running can only target completed items.`);
            } else {
              console.log(`Finished. Re-ran ${rerunWorkflowFailedJobsCount} workflow run(s) (failed jobs) and ${rerunCancelledJobsInRunCount} cancelled job(s) at run-level, plus ${rerunJobLevelCount} job(s) via job-level fallback.`);
            }
